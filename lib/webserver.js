// Generated by CoffeeScript 1.4.0
(function() {
  var Config, Identity, Logger, User, WebServer, async, errorHandler, express, fs, generate_identity, http, plist, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs.extra');

  express = require('express');

  http = require('http');

  plist = require('plist');

  async = require('async');

  require('pkginfo')(module, 'name', 'version');

  Config = require('./config');

  Logger = require('./logger');

  _ref = require('./identity'), Identity = _ref.Identity, generate_identity = _ref.generate_identity;

  User = require('./models/user');

  errorHandler = function(err, req, res, next) {
    res.status(500);
    return res.render('error', {
      error: err
    });
  };

  /**
   * The iOS-ota webserver class.
  */


  WebServer = (function() {

    function WebServer() {
      this.archive_plist_update = __bind(this.archive_plist_update, this);
      this.plist_bundle_version = __bind(this.plist_bundle_version, this);
      this.authenticate_with_self_admin = __bind(this.authenticate_with_self_admin, this);
      this.authenticate = __bind(this.authenticate, this);
      this.redirect_to_plist = __bind(this.redirect_to_plist, this);
      this.is_ios_useragent = __bind(this.is_ios_useragent, this);
      this.setup_routing = __bind(this.setup_routing, this);      this.config = Config.get();
      this.logger = Logger.get();
      this.identity = Identity.get();
      this.app = express();
      this.app.configure;
      this.app.use(express.bodyParser({
        uploadDir: '/tmp',
        keepExtensions: false
      }));
      this.app.use(errorHandler);
      this.setup_routing();
      this.srv = http.createServer(this.app);
      this.srv.listen(this.config.get('port'));
      this.logger.info("Webserver is up at: http://0.0.0.0:" + (this.config.get('port')));
    }

    WebServer.prototype.setup_routing = function() {
      var _this = this;
      this.app.get('/', function(req, res, next) {
        return res.json(200, {
          name: exports.name,
          version: exports.version
        });
      });
      this.app.get('/help', function(req, res, next) {
        return res.json(200, {
          message: "restdown docs coming soon."
        });
      });
      this.app.get('/favicon.ico', function(req, res, next) {
        return res.json(404, "No favicon exists.");
      });
      this.app.get('/users', function(req, res, next) {
        var user;
        user = new User;
        return user.list(function(err, userlist) {
          if (err) {
            res.json(500, "Error retrieving user list.");
          }
          return res.json(200, {
            users: userlist
          });
        });
      });
      this.app.post('/users/:user', function(req, res, next) {
        var handle_auth_response, user;
        user = req.params.user;
        handle_auth_response = function(err, reply) {
          if (err) {
            if (err.code === "UserDoesNotExist") {
              res.json(401, {
                code: 401,
                message: err.message
              });
            }
            if (err.code === "InvalidPassword") {
              res.json(401, {
                code: 401,
                message: "Unauthorized: Invalid authentication secret."
              });
            } else {
              res.json(500, {
                code: 500,
                message: reply.message
              });
            }
          }
          if (user.username === "admin") {
            res.json(403, {
              code: 403,
              message: "Unable to modify the administrative user."
            });
          }
          if (!reply.admin) {
            res.json(401, {
              code: 401,
              message: "Only administrators are permitted to modify accounts."
            });
          }
          user = new User({
            name: req.params.user
          });
          return user.save(function(err, reply) {
            return res.json(200, reply);
          });
        };
        return _this.authenticate_with_self_admin(req, handle_auth_response, user);
      });
      this.app.get('/:user', function(req, res, next) {
        var location, user, username;
        username = req.params.user;
        location = username;
        user = new User({
          name: username
        });
        return user.exists(username, function(err, user_resp) {
          if (err) {
            res.json(500, {
              code: 500,
              location: location,
              user: username,
              message: "Error retrieving info for user `" + username + "`."
            });
          }
          if (!user_resp) {
            res.json(404, {
              code: 404,
              location: location,
              user: username,
              message: "The user `" + username + "` does not exist."
            });
          }
          return user.applications().list(function(err, reply) {
            if (err) {
              res.json(500, {
                code: 500,
                location: location,
                user: username,
                message: "Error retrieving apps for user `" + username + "`."
              });
            }
            return res.json(200, {
              user: username,
              location: location,
              applications: reply
            });
          });
        });
      });
      this.app.del('/users/:user', function(req, res, next) {
        var target, user;
        target = req.params.user;
        if (target === "admin") {
          res.json(403, {
            code: 403,
            message: "Unable to modify internal services."
          });
        }
        user = new User();
        return user["delete"](target, function(err, reply) {
          return res.json(200, {
            message: "Successfully deleted user `" + target + "`."
          });
        });
      });
      this.app.put('/:user/:app', function(req, res, next) {
        var user;
        user = new User({
          name: req.params.user
        });
        return user.applications().build(req.params.app).save(function(err, reply) {
          return res.json(200, {
            message: "Successfully updated application `" + req.params.app + "`."
          });
        });
      });
      this.app.get('/:user/:app', function(req, res, next) {
        var app, loc, location, user;
        location = [req.params.user, req.params.app];
        loc = location.join('/');
        user = new User({
          name: req.params.user
        });
        app = user.applications();
        return app.build(req.params.app).find(req.params.app, function(err, reply) {
          if (err) {
            res.json(404, {
              code: 404,
              user: req.params.user,
              app: req.params.app,
              location: loc,
              message: "The application `" + req.params.app + "` does not exist."
            });
          }
          return res.json(200, {
            user: req.params.user,
            app: req.params.app,
            location: loc,
            branches: reply.branches,
            tags: reply.tags
          });
        });
      });
      this.app.get('/:user/:app/branches', function(req, res, next) {
        var app, branches, loc, location, user;
        location = [req.params.user, req.params.app, 'branches'];
        loc = location.join('/');
        location.unshift(_this.config.get('repository'));
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branches = app.branches();
        return branches.list(function(err, reply) {
          return res.json(200, {
            name: loc,
            branches: reply
          });
        });
      });
      this.app.get('/:user/:app/tags', function(req, res, next) {
        var app, loc, location, tags, user;
        location = [req.params.user, req.params.app, 'tags'];
        loc = location.join('/');
        location.unshift(_this.config.get('repository'));
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        tags = app.tags();
        return tags.list(function(err, reply) {
          return res.json(200, {
            name: loc,
            tags: reply
          });
        });
      });
      this.app.post('/:user/:app/tags/:tag', function(req, res, next) {
        var app, tag, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        tag = app.tags().build(req.params.tag);
        return tag.save(function(err, reply) {
          var f, f_normal, files, flist, k, mapto_flist;
          if (typeof req.files === void 0) {
            return res.json(200, {
              name: reply
            });
          } else {
            mapto_flist = function(file) {
              return {
                location: file.path,
                name: file.name
              };
            };
            flist = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = Object.keys(req.files);
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  k = _ref1[_i];
                  _results.push(req.files[k]);
                }
                return _results;
              })()
            ];
            f_normal = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = flist[0];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  f = _ref1[_i];
                  _results.push(mapto_flist(f));
                }
                return _results;
              })()
            ][0];
            files = tag.files();
            return files.save(f_normal, function(err, reply) {
              return res.json(200, {
                files: reply
              });
            });
          }
        });
      });
      this.app.post('/:user/:app/branches/:branch', function(req, res, next) {
        var app, branch, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        return branch.save(function(err, reply) {
          var a_normal, f, f_normal, flist, k, mapto_flist, plist_file, return_files;
          if (typeof req.files === void 0) {
            return res.json(200, {
              name: reply
            });
          } else {
            mapto_flist = function(file) {
              return {
                location: file.path,
                name: file.name
              };
            };
            if (!req.files) {
              res.json(200, {
                message: "ok"
              });
            }
            flist = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = Object.keys(req.files);
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  k = _ref1[_i];
                  _results.push(req.files[k]);
                }
                return _results;
              })()
            ];
            f_normal = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = flist[0];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  f = _ref1[_i];
                  _results.push(mapto_flist(f));
                }
                return _results;
              })()
            ][0];
            a_normal = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = flist[0];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  f = _ref1[_i];
                  _results.push(mapto_flist(f));
                }
                return _results;
              })()
            ][0];
            return_files = function() {
              var files;
              files = branch.files();
              return files.save(f_normal, function(err, reply) {
                return res.json(200, {
                  files: reply
                });
              });
            };
            if (_this.config.get('archive')) {
              plist_file = (f_normal.filter(function(X) {
                return /\.plist/.test(X['name']);
              })).pop();
              return _this.plist_bundle_version(plist_file['location'], function(err, ref) {
                var copy_archive_file;
                copy_archive_file = function(location_map, fn) {
                  var loc, new_loc;
                  loc = location_map['location'];
                  new_loc = "" + loc + "_archive" + ref;
                  return fs.copy(loc, new_loc, function(err) {
                    var name_match, new_name;
                    location_map['location'] = new_loc;
                    name_match = location_map['name'].match(/(\S+)\.(ipa|plist)/);
                    new_name = "" + ref + "." + name_match[2];
                    location_map['name'] = new_name;
                    return fn(err, location_map);
                  });
                };
                return async.map(a_normal, copy_archive_file, function(err, results) {
                  var afiles, archive;
                  archive = branch.archives().build(ref);
                  afiles = archive.files();
                  return afiles.save(results, function(err, reply) {
                    return return_files();
                  });
                });
              });
            } else {
              return return_files();
            }
          }
        });
      });
      this.app.post('/:user/:app/branches/:branch/archives/:ref', function(req, res, next) {
        var app, archive, branch, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        archive = branch.archives().build(req.params.ref);
        return archive.save(function(err, reply) {
          var f, f_normal, flist, k, mapto_flist, plist_file;
          if (typeof req.files === void 0) {
            return res.json(200, {
              name: reply
            });
          } else {
            mapto_flist = function(file) {
              return {
                location: file.path,
                name: file.name
              };
            };
            if (!req.files) {
              res.json(200, {
                message: "ok"
              });
            }
            flist = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = Object.keys(req.files);
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  k = _ref1[_i];
                  _results.push(req.files[k]);
                }
                return _results;
              })()
            ];
            f_normal = [
              (function() {
                var _i, _len, _ref1, _results;
                _ref1 = flist[0];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  f = _ref1[_i];
                  _results.push(mapto_flist(f));
                }
                return _results;
              })()
            ][0];
            plist_file = (f_normal.filter(function(X) {
              return /\.plist/.test(X['name']);
            })).pop();
            return _this.archive_plist_update(plist_file['location'], function(err, data) {
              var files;
              files = archive.files();
              return files.save(f_normal, function(err, reply) {
                return res.json(200, {
                  files: reply
                });
              });
            });
          }
        });
      });
      this.app.get('/:user/:app/tags/:tag', function(req, res, next) {
        var app, rel_url, tag, user;
        rel_url = "" + req.params.user + "/" + req.params.app + "/tags/" + req.params.tag;
        if (_this.is_ios_useragent(req)) {
          res.redirect(302, "" + rel_url + "/download");
        }
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        tag = app.tags().build(req.params.tag);
        return tag.find(req.params.tag, function(err, reply) {
          return res.json(200, reply);
        });
      });
      this.app.get('/:user/:app/branches/:branch', function(req, res, next) {
        var app, branch, rel_url, user;
        rel_url = "" + req.params.user + "/" + req.params.app + "/tags/" + req.params.tag;
        if (_this.is_ios_useragent(req)) {
          res.redirect(302, "" + rel_url + "/download");
        }
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        return branch.find(req.params.branch, function(err, reply) {
          return res.json(200, reply);
        });
      });
      this.app.get('/:user/:app/branches/:branch/archives', function(req, res, next) {
        var app, archives, branch, loc, location, user;
        location = [req.params.user, req.params.app, 'branches', req.params.branch, 'archives'];
        loc = location.join('/');
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        archives = branch.archives();
        return archives.list(function(err, reply) {
          return res.json(200, {
            name: loc,
            archives: reply
          });
        });
      });
      this.app.del('/:user/:app/tags/:tag', function(req, res, next) {
        var app, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        return app.tags()["delete"](req.params.tag, function(err, reply) {
          return res.json(200, {
            message: "successfully deleted `" + req.params.tag + "`."
          });
        });
      });
      this.app.del('/:user/:app/branches/:branch', function(req, res, next) {
        var app, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        return app.branches()["delete"](req.params.branch, function(err, reply) {
          return res.json(200, {
            message: "successfully deleted `" + req.params.branch + "`."
          });
        });
      });
      this.app.del('/:user/:app/branches/:branch/archives/:ref', function(req, res, next) {
        var app, archives, branch, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        archives = branch.archives().build(req.params.ref);
        return archives["delete"](req.params.ref, function(err, reply) {
          return res.json(200, {
            message: "successfully deleted `" + req.params.ref + "`."
          });
        });
      });
      this.app.get('/:user/:app/tags/:tag/download', function(req, res, next) {
        var rel_url, tg;
        rel_url = "" + req.params.user + "/" + req.params.app + "/tags/" + req.params.tag + "/download";
        tg = req.params.tag;
        return res.redirect(301, "" + rel_url + "/" + tg + ".plist");
      });
      this.app.get('/:user/:app/branches/:branch/download', function(req, res, next) {
        var br, rel_url;
        rel_url = "" + req.params.user + "/" + req.params.app + "/branches/" + req.params.branch + "/download";
        br = req.params.branch;
        return res.redirect(301, "" + rel_url + "/" + br + ".plist");
      });
      this.app.get('/:user/:app/branches/:branch/archives/:ref/download', function(req, res, next) {
        var ref, rel_url;
        rel_url = "" + req.params.user + "/" + req.params.app + "/branches/" + req.params.branch + "/archives/" + req.params.ref + "/download";
        ref = req.params.ref;
        return res.redirect(301, "" + rel_url + "/" + ref + ".plist");
      });
      this.app.get('/:user/:app/branches/:branch/download/:file', function(req, res, next) {
        var app, branches, ct, target, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branches = app.branches().build(req.params.branch);
        target = branches.files().filepath(req.params.file);
        if (/plist$/.test(req.params.file)) {
          ct = 'text/xml';
        } else {
          ct = 'application/octet-stream';
        }
        return fs.stat(target, function(err, reply) {
          var readStream;
          res.writeHead(200, {
            'Content-Type': ct,
            'Content-Length': reply.size
          });
          return readStream = fs.createReadStream(target, {
            bufferSize: 4 * 1024
          }).pipe(res);
        });
      });
      this.app.get('/:user/:app/tags/:tag/download/:file', function(req, res, next) {
        var app, ct, tags, target, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        tags = app.tags().build(reqs.params.tag);
        target = branches.files().filepath(req.params.file);
        if (/plist$/.test(req.params.file)) {
          ct = 'text/xml';
        } else {
          ct = 'application/octet-stream';
        }
        return fs.stat(target, function(err, reply) {
          var readStream;
          res.writeHead(200, {
            'Content-Type': ct,
            'Content-Length': reply.size
          });
          return readStream = fs.createReadStream(target, {
            bufferSize: 4 * 1024
          }).pipe(res);
        });
      });
      return this.app.get('/:user/:app/branches/:branch/archives/:ref/download/:file', function(req, res, next) {
        var app, archives, branch, ct, target, user;
        user = new User({
          name: req.params.user
        });
        app = user.applications().build(req.params.app);
        branch = app.branches().build(req.params.branch);
        archives = branch.archives().build(req.params.ref);
        target = archives.files().filepath(req.params.file);
        if (/plist$/.test(req.params.file)) {
          ct = 'text/xml';
        } else {
          ct = 'application/octet-stream';
        }
        return fs.stat(target, function(err, reply) {
          var readStream;
          res.writeHead(200, {
            'Content-Type': ct,
            'Content-Length': reply.size
          });
          return readStream = fs.createReadStream(target, {
            bufferSize: 4 * 1024
          }).pipe(res);
        });
      });
    };

    /**
     * Check what the user-agent is an iPhone or iPad.
     * @params {Object} (req) The express request object
     * @return {Boolean} Whether or not the user-agent is an iphone/ipad
    */


    WebServer.prototype.is_ios_useragent = function(req) {
      var ua_regex;
      ua_regex = /[iI][pP](hone|ad)/;
      if (req.headers.hasOwnProperty('user-agent')) {
        return req.headers['user-agent'].match(ua_regex) !== null;
      } else {
        return null;
      }
    };

    WebServer.prototype.redirect_to_plist = function(req, res, next) {
      return res.redirect(302, '/');
    };

    /**
     * Authenticates the user.
     * @param {Object} (req) The express request object
     * @param {Function} (fn) The callback function
    */


    WebServer.prototype.authenticate = function(req, fn) {
      var credentials, err, reply, user,
        _this = this;
      err = false;
      credentials = {
        username: req.body.username,
        secret: req.body.secret
      };
      if (!credentials.username) {
        err = true;
        reply = {
          code: 401,
          message: "Unauthorized: No username parameter was provided."
        };
      }
      if (!credentials.secret) {
        err = true;
        reply = {
          code: 401,
          message: "Unauthorized: No secret parameter was provided."
        };
      }
      if (credentials.username === "admin") {
        if (credentials.secret !== this.config.get('admin_secret')) {
          err = true;
          reply = {
            code: 401,
            message: "Unauthorized: Invalid authentication secret."
          };
        } else {
          reply = {
            admin: true
          };
        }
        return fn(err, reply);
      } else {
        user = new User();
        return user.check_login(credentials, function(err, authenticated) {
          if (authenticated) {
            reply = {
              admin: false
            };
          } else if (err.code === "ErrorConnectingToRedis") {
            err = true;
            reply = {
              code: 500,
              message: "Error connecting to redis."
            };
          } else {
            err = true;
            reply = {
              code: 401,
              message: "Unauthorized: Invalid authentication secret."
            };
          }
          return fn(err, reply);
        });
      }
    };

    /**
     * Authenticates the user, and if the user is managing themselves, elevate.
     * @param {Object} (req) The express request object
     * @param {Function} (fn) The callback function
     * @param {String} (user) The user to test against for elevated privs
    */


    WebServer.prototype.authenticate_with_self_admin = function(req, fn, user) {
      var credentials,
        _this = this;
      credentials = {
        username: req.body.username,
        secret: req.body.secret
      };
      return this.authenticate(req, function(err, reply) {
        if (credentials.username === user) {
          reply.admin = true;
        }
        return fn(err, reply);
      });
    };

    /**
     * Retrieve plist bundle-version.
     * @param {String}   (location) The location of the plist
     * @param {Function} (fn) The callback function
    */


    WebServer.prototype.plist_bundle_version = function(location, fn) {
      var _this = this;
      return fs.readFile(location, function(err, data) {
        var pdata, ref;
        pdata = plist.parseStringSync(data.toString());
        ref = pdata.items[0].metadata['bundle-version'];
        return fn(err, ref);
      });
    };

    /**
     * Takes a given plist and forces the download url to point to archives.
     * @param {String}   (location) The location of the plist to modify
     * @param {Function} (fn) The callback function
    */


    WebServer.prototype.archive_plist_update = function(location, fn) {
      var _this = this;
      return fs.readFile(location, function(err, data) {
        var ipa_match, pdata, ref, updated_pdata, url;
        pdata = plist.parseStringSync(data.toString());
        ref = pdata.items[0].metadata['bundle-version'];
        url = pdata.items[0].assets[0].url;
        ipa_match = url.match(/\/download\/(\S+)\.ipa/);
        pdata.items[0].assets[0]['url'] = url.replace("/download/" + ipa_match[1] + ".ipa", "/archives/" + ref + "/download/" + ref + ".ipa");
        updated_pdata = plist.build(pdata).toString();
        return fs.writeFile(location, updated_pdata, function(err) {
          return fn(err, updated_pdata);
        });
      });
    };

    return WebServer;

  })();

  module.exports = WebServer;

}).call(this);
